<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>我的首页</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="background" class="background"></div>

  <div id="app" class="app">
    <header class="topbar">
      <div class="top-actions">
        <div id="topSearchWrap" class="top-search">
          <input id="topSearch" type="search" placeholder="搜索标题或网址..." autocomplete="off" />
          <button id="btnSearch" class="icon-btn search-btn" data-tooltip="搜索">搜索</button>
        </div>
        <div class="toolbar">
          <button id="btnAdd" class="icon-btn" data-tooltip="新增快捷按钮">新增</button>
          <button id="btnBatchDelete" class="icon-btn" data-tooltip="批量删除">批量删除</button>
          <button id="btnSelectAll" class="icon-btn hidden" data-tooltip="全选">全选</button>
          <button id="btnOpenMode" class="icon-btn" data-tooltip="打开方式">打开方式</button>
          <button id="btnSettings" class="icon-btn" data-tooltip="设置">设置</button>
        </div>
      </div>
    </header>

    <div class="layout">
      <aside class="sidebar" aria-label="分组">
        <button id="recentTab" class="group-tab recent-tab">最近浏览</button>
        <div id="groupTabs" class="group-tabs vertical"></div>
        <button id="btnAddGroup" class="icon-btn add-group">新增分组</button>
        <button id="btnToggleSidebar" class="icon-btn add-group toggle-btn">收起</button>
      </aside>

      <main class="main">
        <div id="grid" class="grid" tabindex="0" aria-label="快捷按钮网格"></div>
      <div id="emptyState" class="empty-state hidden">
        <div class="empty-box">
          <div class="empty-title">还没有快捷按钮</div>
          <div class="empty-desc">点击右上角新增 / 导入 JSON 添加快捷按钮</div>
          <label class="empty-check"><input id="emptyHintToggle" type="checkbox"> 不再提示</label>
        </div>
      </div>
    </main>
    </div>
  </div>

  <div id="folderOverlay" class="overlay hidden" aria-hidden="true">
    <div class="overlay-header">
      <button id="btnCloseFolder" class="icon-btn">返回</button>
      <div id="folderTitle" class="overlay-title"></div>
      <div class="overlay-actions">
        <button id="btnFolderAdd" class="icon-btn">新增</button>
        <button id="btnFolderBatchDelete" class="icon-btn">批量删除</button>
      </div>
    </div>
    <div id="folderGrid" class="grid overlay-grid" tabindex="0" aria-label="文件夹内容"></div>
  </div>

  <div id="modalOverlay" class="modal-overlay hidden" aria-hidden="true">
    <div id="modal" class="modal" role="dialog" aria-modal="true"></div>
  </div>

  <div id="contextMenu" class="context-menu hidden" role="menu"></div>
  <div id="toastContainer" class="toast-container" aria-live="polite"></div>
  <div id="tooltip" class="tooltip hidden"></div>

  <script>
/* Firefox bundle (no ESM imports) */

const ROOT_KEY = "homepage_data";
const ICON_CACHE_KEY = "homepage_icon_cache";
const BG_CACHE_KEY = "homepage_bg_cache";
const SYNC_ITEM_QUOTA_BYTES = 7500;

const DEFAULT_SETTINGS = {
  showSearch: true,
  enableSearchEngine: true,
  searchEngineUrl: "https://www.bing.com/search?q=",
  openMode: "current",
  fixedLayout: false,
  fixedCols: 8,
  gridDensity: "standard",
  fontSize: 13,
  tooltipEnabled: true,
  emptyHintDisabled: false,
  backgroundType: "bing",
  backgroundColor: "#0b0f14",
  backgroundGradient: "linear-gradient(120deg,#1d2a3b,#0b0f14)",
  backgroundGradientA: "#1d2a3b",
  backgroundGradientB: "#0b0f14",
  backgroundCustom: "",
  backgroundFade: true,
  backgroundOverlayStrength: 0.08,
  iconFetch: true,
  iconRetryAtSix: true,
  iconRetryHour: 18,
  syncEnabled: false,
  maxBackups: 30,
  keyboardNav: true,
  lastActiveGroupId: "",
  defaultGroupMode: "last",
  defaultGroupId: "",
  theme: "system",
  lastSaveUrl: "",
  lastSaveTs: 0,
  sidebarCollapsed: false,
  sidebarHidden: false,
};

function nowTs() {
  return Date.now();
}

function createDefaultData() {
  const groupId = `grp_${nowTs()}`;
  return {
    schemaVersion: 1,
    settings: { ...DEFAULT_SETTINGS },
    groups: [
      { id: groupId, name: "默认", order: 0, nodes: [] }
    ],
    nodes: {},
    backups: [],
    lastUpdated: nowTs(),
  };
}

function getChrome() {
  if (typeof chrome !== "undefined") return chrome;
  if (typeof browser !== "undefined") return browser;
  return null;
}

function storageArea(useSync) {
  const api = getChrome();
  if (!api || !api.storage) return null;
  return useSync ? api.storage.sync : api.storage.local;
}

function getLastError() {
  const api = getChrome();
  return api?.runtime?.lastError || null;
}

function estimateBytes(value) {
  const str = JSON.stringify(value);
  if (typeof TextEncoder !== "undefined") {
    return new TextEncoder().encode(str).length;
  }
  return str.length;
}

function isQuotaError(err) {
  return typeof err === "string" && err.toLowerCase().includes("quota");
}

function trimLocalBackups(data) {
  if (Array.isArray(data.backups) && data.backups.length) {
    data.backups = [];
    return true;
  }
  return false;
}

function trimLocalUploadIcons(data) {
  let changed = false;
  for (const node of Object.values(data.nodes || {})) {
    if (node.iconType === "upload" && node.iconData) {
      node.iconData = "";
      node.iconType = "auto";
      changed = true;
    }
  }
  return changed;
}

function trimLocalBackground(data) {
  if (data.settings?.backgroundType === "custom" && data.settings.backgroundCustom) {
    data.settings.backgroundCustom = "";
    return true;
  }
  return false;
}

async function storageGet(area, key) {
  return new Promise((resolve) => {
    let done = false;
    const finish = (value) => {
      if (done) return;
      done = true;
      resolve(value);
    };
    try {
      const result = area.get(key, (res) => {
        const err = getLastError();
        if (err) return finish(undefined);
        finish(res?.[key]);
      });
      if (result && typeof result.then === "function") {
        result.then((res) => finish(res?.[key]), () => finish(undefined));
      }
    } catch {
      finish(undefined);
    }
  });
}

async function storageSet(area, obj) {
  return new Promise((resolve) => {
    let done = false;
    const finish = (errMsg) => {
      if (done) return;
      done = true;
      resolve(errMsg);
    };
    try {
      const result = area.set(obj, () => {
        const err = getLastError();
        finish(err ? err.message : null);
      });
      if (result && typeof result.then === "function") {
        result.then(() => finish(null), (err) => finish(err?.message || String(err)));
      }
    } catch (err) {
      finish(err?.message || String(err));
    }
  });
}

async function storageRemove(area, key) {
  return new Promise((resolve) => {
    let done = false;
    const finish = (errMsg) => {
      if (done) return;
      done = true;
      resolve(errMsg);
    };
    try {
      const result = area.remove(key, () => {
        const err = getLastError();
        finish(err ? err.message : null);
      });
      if (result && typeof result.then === "function") {
        result.then(() => finish(null), (err) => finish(err?.message || String(err)));
      }
    } catch (err) {
      finish(err?.message || String(err));
    }
  });
}

function migrateData(data) {
  if (!data || !data.schemaVersion) return data;
  // placeholder for future migrations
  return data;
}

async function loadData() {
  const base = createDefaultData();
  const api = getChrome();
  if (!api) return base;

  const local = storageArea(false);
  let data = await storageGet(local, ROOT_KEY);
  if (!data) {
    await storageSet(local, { [ROOT_KEY]: base });
    return base;
  }
  data = migrateData(data) || base;
  data.settings = { ...DEFAULT_SETTINGS, ...(data.settings || {}) };
  return data;
}

async function loadDataFromArea(useSync = false) {
  const base = createDefaultData();
  const api = getChrome();
  if (!api) return base;
  const area = storageArea(useSync);
  let data = await storageGet(area, ROOT_KEY);
  if (!data) return base;
  data = migrateData(data) || base;
  data.settings = { ...DEFAULT_SETTINGS, ...(data.settings || {}) };
  return data;
}

async function saveData(data, useSync = false) {
  const api = getChrome();
  if (!api) return;
  const area = storageArea(useSync);
  data.lastUpdated = nowTs();
  const payload = useSync ? sanitizeForSync(data) : data;
  if (useSync) {
    const size = estimateBytes(payload);
    if (size > SYNC_ITEM_QUOTA_BYTES) {
      data.settings.syncEnabled = false;
      await storageSet(storageArea(false), { [ROOT_KEY]: data });
      return "sync_quota_exceeded";
    }
  }
  let err = await storageSet(area, { [ROOT_KEY]: payload });
  if (!useSync && err && isQuotaError(err)) {
    if (trimLocalBackups(data)) {
      err = await storageSet(area, { [ROOT_KEY]: data });
      if (!err) return "local_trimmed_backups";
    }
    if (trimLocalUploadIcons(data)) {
      err = await storageSet(area, { [ROOT_KEY]: data });
      if (!err) return "local_trimmed_icons";
    }
    if (trimLocalBackground(data)) {
      err = await storageSet(area, { [ROOT_KEY]: data });
      if (!err) return "local_trimmed_background";
    }
  }
  if (err && useSync) {
    data.settings.syncEnabled = false;
    await storageSet(storageArea(false), { [ROOT_KEY]: data });
  }
  return err;
}

async function clearData(useSync = false) {
  const api = getChrome();
  if (!api) return;
  const area = storageArea(useSync);
  await storageRemove(area, ROOT_KEY);
}

async function loadIconCache() {
  const api = getChrome();
  if (!api) return {};
  const local = storageArea(false);
  return (await storageGet(local, ICON_CACHE_KEY)) || {};
}

async function saveIconCache(cache) {
  const api = getChrome();
  if (!api) return;
  const local = storageArea(false);
  await storageSet(local, { [ICON_CACHE_KEY]: cache });
}

async function loadBgCache() {
  const api = getChrome();
  if (!api) return {};
  const local = storageArea(false);
  return (await storageGet(local, BG_CACHE_KEY)) || {};
}

async function saveBgCache(cache) {
  const api = getChrome();
  if (!api) return;
  const local = storageArea(false);
  await storageSet(local, { [BG_CACHE_KEY]: cache });
}

function sanitizeForSync(data) {
  const clone = JSON.parse(JSON.stringify(data));
  if (clone.settings) {
    if (clone.settings.backgroundType === "custom") {
      clone.settings.backgroundCustom = "";
    }
  }
  clone.backups = [];
  for (const node of Object.values(clone.nodes || {})) {
    if (node.iconType === "upload" && node.iconData && node.iconData.length > 2048) {
      node.iconData = "";
      node.iconType = "auto";
    }
  }
  return clone;
}

function createBackupSnapshot(data) {
  return {
    id: `bak_${nowTs()}`,
    ts: nowTs(),
    data: JSON.parse(JSON.stringify(data)),
  };
}

function defaultSettings() {
  return { ...DEFAULT_SETTINGS };
}

function defaultData() {
  return createDefaultData();
}

function getStorageKey() {
  return ROOT_KEY;
}

function getChromeApi() {
  return getChrome();
}

const FAVICON_API = "https://www.google.com/s2/favicons?domain=";
const MULTI_PART_TLDS = new Set([
  "co.uk",
  "org.uk",
  "ac.uk",
  "gov.uk",
  "co.jp",
  "ne.jp",
  "or.jp",
  "com.cn",
  "net.cn",
  "org.cn",
  "gov.cn",
  "edu.cn",
  "com.au",
  "net.au",
  "org.au",
  "com.br",
  "com.tw",
  "com.hk",
]);

function hashColor(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
  }
  const c = (hash & 0x00ffffff).toString(16).toUpperCase();
  return `#${"00000".substring(0, 6 - c.length)}${c}`;
}

function avatarDataUrl(text, color) {
  const canvas = document.createElement("canvas");
  canvas.width = 128;
  canvas.height = 128;
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = color;
  ctx.fillRect(0, 0, 128, 128);
  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.font = "bold 64px sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text.slice(0, 1).toUpperCase(), 64, 72);
  return canvas.toDataURL("image/png");
}

function isHttpUrl(pageUrl) {
  try {
    const u = new URL(pageUrl);
    return u.protocol === "http:" || u.protocol === "https:";
  } catch {
    return false;
  }
}

function getRootDomain(host) {
  if (!host) return "";
  const parts = host.split(".").filter(Boolean);
  if (parts.length <= 2) return host;
  const lastTwo = parts.slice(-2).join(".");
  const lastThree = parts.slice(-3).join(".");
  if (MULTI_PART_TLDS.has(lastTwo)) return lastThree;
  if (parts[parts.length - 1].length <= 2) return lastThree;
  return lastTwo;
}

function getSiteKey(pageUrl) {
  try {
    if (!isHttpUrl(pageUrl)) return "";
    const host = new URL(pageUrl).hostname;
    if (!host.includes(".")) return "";
    if (host === "localhost" || host.endsWith(".local")) return "";
    const root = getRootDomain(host);
    return root ? `site:${root}` : "";
  } catch {
    return "";
  }
}

function getFaviconCandidates(pageUrl) {
  try {
    if (!isHttpUrl(pageUrl)) return [];
    const u = new URL(pageUrl);
    const host = u.hostname;
    if (!host.includes(".")) return [];
    if (host === "localhost" || host.endsWith(".local")) return [];
    return [
      `${u.origin}/favicon.ico`,
      `${FAVICON_API}${encodeURIComponent(host)}&sz=128`,
      `https://icons.duckduckgo.com/ip3/${host}.ico`,
    ];
  } catch {
    return [];
  }
}

function buildFaviconUrl(url) {
  const candidates = getFaviconCandidates(url);
  return candidates[0] || "";
}

async function resolveIcon(node, settings) {
  const base = node.title || node.url || "?";
  const isHttp = node.url ? isHttpUrl(node.url) : false;
  const siteKey = node.url ? getSiteKey(node.url) : "";
  const cache = await loadIconCache();
  const cacheKey = node.url || node.id;

  if (node.url && !isHttp) {
    if (cache[cacheKey]) {
      delete cache[cacheKey];
      await saveIconCache(cache);
    }
    return avatarDataUrl(base, node.color || hashColor(base));
  }

  if (node.iconType === "upload" && node.iconData) {
    if (siteKey && !cache[siteKey]) {
      cache[siteKey] = { dataUrl: node.iconData, ts: Date.now() };
      await saveIconCache(cache);
    }
    return node.iconData;
  }

  if (node.iconType === "remote" && node.iconData) {
    if (siteKey && !cache[siteKey]) {
      cache[siteKey] = { url: node.iconData, ts: Date.now() };
      await saveIconCache(cache);
    }
    return node.iconData;
  }

  if (node.iconType === "color") {
    const dataUrl = avatarDataUrl(base, node.color || hashColor(base));
    if (siteKey && !cache[siteKey]) {
      cache[siteKey] = { dataUrl, ts: Date.now() };
      await saveIconCache(cache);
    }
    return dataUrl;
  }

  if (siteKey && cache[siteKey]) {
    return cache[siteKey].url || cache[siteKey].dataUrl;
  }

  if (cache[cacheKey]?.url) return cache[cacheKey].url;
  if (cache[cacheKey]?.dataUrl) return cache[cacheKey].dataUrl;

  if (node.iconType === "letter") {
    const dataUrl = avatarDataUrl(base, node.color || hashColor(base));
    if (siteKey && !cache[siteKey]) {
      cache[siteKey] = { dataUrl, ts: Date.now() };
      await saveIconCache(cache);
    }
    return dataUrl;
  }

  if (settings.iconFetch && node.url) {
    const url = buildFaviconUrl(node.url);
    cache[cacheKey] = { url, ts: Date.now() };
    if (siteKey && !cache[siteKey]) {
      cache[siteKey] = { url, ts: Date.now() };
    }
    await saveIconCache(cache);
    return url;
  }

  return avatarDataUrl(base, node.color || hashColor(base));
}

async function refreshAllIcons(nodes) {
  const cache = await loadIconCache();
  for (const node of nodes) {
    if (!node.url) continue;
    const url = buildFaviconUrl(node.url);
    cache[node.url] = { url, ts: Date.now() };
    const siteKey = getSiteKey(node.url);
    if (siteKey) cache[siteKey] = { url, ts: Date.now() };
  }
  await saveIconCache(cache);
}

async function retryFailedIconsIfDue(settings) {
  const retryHour = settings.iconRetryHour ?? (settings.iconRetryAtSix ? 18 : "");
  if (retryHour === "" || retryHour === null || retryHour === undefined) return;
  const targetHour = Number(retryHour);
  if (!Number.isInteger(targetHour) || targetHour < 0 || targetHour > 23) return;
  const now = new Date();
  if (now.getHours() !== targetHour) return;
  const cache = await loadIconCache();
  let changed = false;
  for (const key of Object.keys(cache)) {
    if (cache[key]) {
      const raw = key.startsWith("site:") ? `https://${key.slice(5)}` : key;
      cache[key] = { url: buildFaviconUrl(raw), ts: Date.now() };
      changed = true;
    }
  }
  if (changed) await saveIconCache(cache);
}

const BING_API = "https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1&mkt=en-US";
const CACHE_TTL_MS = 1000 * 60 * 60 * 6;

function todayKey() {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${y}${m}${day}`;
}

function blobToDataUrl(blob) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result);
    reader.readAsDataURL(blob);
  });
}

async function getBingWallpaper() {
  const cache = await loadBgCache();
  const key = todayKey();

  if (cache && cache.dataUrl) {
    const ts = Number(cache.ts || 0);
    const freshByDate = cache.date === key;
    const freshByTtl = ts > 0 && Date.now() - ts < CACHE_TTL_MS;
    if (freshByDate || freshByTtl) {
      if (!cache.ts) {
        cache.ts = Date.now();
        await saveBgCache(cache);
      }
      return { ...cache, fromCache: true };
    }
  }

  try {
    const res = await fetch(BING_API, { cache: "no-store" });
    const json = await res.json();
    const img = json?.images?.[0];
    if (!img?.url) throw new Error("no bing image");
    const fullUrl = img.url.startsWith("http") ? img.url : `https://www.bing.com${img.url}`;
    const imgRes = await fetch(fullUrl, { cache: "no-store" });
    const blob = await imgRes.blob();
    const dataUrl = await blobToDataUrl(blob);

    const payload = { date: key, url: fullUrl, dataUrl, ts: Date.now() };
    await saveBgCache(payload);
    return { ...payload, fromCache: false };
  } catch (err) {
    if (cache?.dataUrl) return { ...cache, fromCache: true, failed: true };
    return { date: key, url: "", dataUrl: "", failed: true };
  }
}

const $ = (id) => document.getElementById(id);
const qs = (sel, root = document) => root.querySelector(sel);
const qsa = (sel, root = document) => Array.from(root.querySelectorAll(sel));

const elements = {
  background: $("background"),
  grid: $("grid"),
  emptyState: $("emptyState"),
  emptyHintToggle: $("emptyHintToggle"),
  main: document.querySelector(".main"),
  recentTab: $("recentTab"),
  groupTabs: $("groupTabs"),
  topSearch: $("topSearch"),
  topSearchWrap: $("topSearchWrap"),
  btnAdd: $("btnAdd"),
  btnBatchDelete: $("btnBatchDelete"),
  btnSelectAll: $("btnSelectAll"),
  btnOpenMode: $("btnOpenMode"),
  btnSettings: $("btnSettings"),
  btnSearch: $("btnSearch"),
  btnToggleSidebar: $("btnToggleSidebar"),
  btnAddGroup: $("btnAddGroup"),
  modalOverlay: $("modalOverlay"),
  modal: $("modal"),
  contextMenu: $("contextMenu"),
  toastContainer: $("toastContainer"),
  tooltip: $("tooltip"),
  folderOverlay: $("folderOverlay"),
  folderGrid: $("folderGrid"),
  folderTitle: $("folderTitle"),
  btnCloseFolder: $("btnCloseFolder"),
  btnFolderAdd: $("btnFolderAdd"),
  btnFolderBatchDelete: $("btnFolderBatchDelete"),
};

let data = null;
let activeGroupId = null;
let openFolderId = null;
let selectionMode = false;
let selectedIds = new Set();
let pendingDeletion = null;
let tooltipTimer = null;
let dragState = null;
let lastSelectedIndex = null;
let recentItems = [];
let draggingGroupId = null;
let boxSelecting = false;
let selectionBox = null;
let selectionStart = null;
let suppressBlankClick = false;
let isDraggingBox = false;
let settingsOpen = false;
let settingsSaving = false;
let settingsSaveTimer = null;
let settingsSaveQueued = false;
let settingsSaveNow = null;
let renderSeq = 0;
let lastMainLayout = null;
let storageReloadTimer = null;
let pendingStorageReload = false;
const DEBUG_LOG_KEY = "homepage_debug_log";

const RECENT_GROUP_ID = "__recent__";
const RECENT_LIMIT = 24;

const DEFAULT_TILE_SIZE = 96;
const DEFAULT_BASE_FONT = 13;
const densityMap = {
  compact: { gap: 10 },
  standard: { gap: 16 },
  spacious: { gap: 22 },
};
const bgOverlayMap = {
  light: "rgba(245, 246, 250, 0.85)",
  dark: "rgba(12, 15, 20, 0.72)",
};

function debugLog(event, payload = {}) {
  const entry = { ts: Date.now(), event, payload };
  try {
    const raw = localStorage.getItem(DEBUG_LOG_KEY);
    const list = raw ? JSON.parse(raw) : [];
    list.unshift(entry);
    localStorage.setItem(DEBUG_LOG_KEY, JSON.stringify(list.slice(0, 200)));
  } catch (err) {
    console.warn("debugLog failed", err);
  }
  console.log("[debug]", entry);
}

function getRuntimeInfo() {
  const api = getChromeApi();
  return {
    runtimeId: api?.runtime?.id || "",
    href: window.location.href,
    origin: window.location.origin,
  };
}

function shouldDebugPersist() {
  try {
    return localStorage.getItem("homepage_debug_persist") === "1";
  } catch {
    return false;
  }
}

async function loadLatestDataForApp() {
  const localData = await loadData();
  if (localData.settings.syncEnabled) {
    const syncData = await loadDataFromArea(true);
    if (syncData && syncData.groups?.length) {
      const localTs = Number(localData.lastUpdated || 0);
      const syncTs = Number(syncData.lastUpdated || 0);
      return syncTs >= localTs ? syncData : localData;
    }
  }
  return localData;
}

async function reloadFromStorage() {
  const prevActive = activeGroupId;
  const prevOpenFolder = openFolderId;
  const prevSelected = new Set(selectedIds);
  data = await loadLatestDataForApp();
  if (prevActive === RECENT_GROUP_ID) {
    activeGroupId = RECENT_GROUP_ID;
  } else if (prevActive && data.groups.find((g) => g.id === prevActive)) {
    activeGroupId = prevActive;
  } else {
    activeGroupId = data.groups?.[0]?.id || RECENT_GROUP_ID;
  }
  if (prevOpenFolder && data.nodes?.[prevOpenFolder]?.type === "folder") {
    openFolderId = prevOpenFolder;
  } else {
    openFolderId = null;
  }
  selectedIds = new Set([...prevSelected].filter((id) => data.nodes?.[id]));
  render();
}

function scheduleStorageReload() {
  if (settingsOpen) {
    pendingStorageReload = true;
    return;
  }
  if (storageReloadTimer) clearTimeout(storageReloadTimer);
  storageReloadTimer = setTimeout(async () => {
    storageReloadTimer = null;
    await reloadFromStorage();
  }, 120);
}

function attachStorageListener() {
  const api = getChromeApi();
  if (!api?.storage?.onChanged) return;
  const key = getStorageKey();
  api.storage.onChanged.addListener((changes, areaName) => {
    if (!changes || !changes[key]) return;
    if (areaName !== "local" && areaName !== "sync") return;
    scheduleStorageReload();
  });
}

window.homepageDebugLog = () => {
  try {
    return JSON.parse(localStorage.getItem(DEBUG_LOG_KEY) || "[]");
  } catch {
    return [];
  }
};

window.homepageDebugEnv = async () => {
  const api = getChromeApi();
  const info = getRuntimeInfo();
  return new Promise((resolve) => {
    if (!api?.storage?.local?.getBytesInUse) return resolve(info);
    api.storage.local.getBytesInUse("homepage_data", (bytes) => {
      resolve({ ...info, bytes });
    });
  });
};

function applyDensity() {
  const d = densityMap[data.settings.gridDensity] || densityMap.standard;
  document.documentElement.style.setProperty("--grid-gap", `${d.gap}px`);
  const baseFont = Number(data.settings.fontSize) || DEFAULT_BASE_FONT;
  document.documentElement.style.setProperty("--tile-font", `${baseFont}px`);
  document.documentElement.style.setProperty("--base-font", `${baseFont}px`);
  if (!data.settings.lastTileSize || data.settings.lastTileSize <= 0) {
    data.settings.lastTileSize = DEFAULT_TILE_SIZE;
  }
}

function applyTheme() {
  const theme = data.settings.theme || "system";
  if (theme === "system") {
    const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    document.documentElement.setAttribute("data-theme", prefersDark ? "dark" : "light");
    applyBackgroundOverlay();
    return;
  }
  document.documentElement.setAttribute("data-theme", theme);
  applyBackgroundOverlay();
}

function applySidebarState() {
  document.body.classList.toggle("sidebar-collapsed", !!data.settings.sidebarCollapsed);
  document.body.classList.toggle("sidebar-hidden", !!data.settings.sidebarHidden);
  if (elements.btnToggleSidebar) {
    elements.btnToggleSidebar.textContent = data.settings.sidebarCollapsed ? "展开" : "收起";
  }
  syncSidebarTabLabels();
}

function syncSidebarTabLabels() {
  if (!elements.recentTab) return;
  const collapsed = !!data.settings.sidebarCollapsed;
  const recentLabel = elements.recentTab.dataset.label || elements.recentTab.textContent || "最近浏览";
  elements.recentTab.dataset.label = recentLabel;
  elements.recentTab.setAttribute("aria-label", recentLabel);
  elements.recentTab.textContent = collapsed ? "" : recentLabel;
  qsa(".group-tab", elements.groupTabs).forEach((btn) => {
    const label = btn.dataset.label || btn.textContent || "";
    btn.dataset.label = label;
    btn.setAttribute("aria-label", label || "分组");
    btn.textContent = collapsed ? "" : label;
  });
}

function toast(message, actionLabel, action) {
  const el = document.createElement("div");
  el.className = "toast";
  el.innerHTML = `<span>${message}</span>`;
  if (actionLabel && action) {
    const btn = document.createElement("button");
    btn.textContent = actionLabel;
    btn.addEventListener("click", () => {
      action();
      el.remove();
    });
    el.appendChild(btn);
  }
  elements.toastContainer.appendChild(el);
  setTimeout(() => el.remove(), 5000);
}

function showTooltip(text, x, y) {
  if (!data.settings.tooltipEnabled) return;
  elements.tooltip.textContent = text;
  elements.tooltip.style.left = `${x + 12}px`;
  elements.tooltip.style.top = `${y + 12}px`;
  elements.tooltip.classList.remove("hidden");
}

function hideTooltip() {
  elements.tooltip.classList.add("hidden");
}

function normalizeUrl(input) {
  if (!input) return "";
  try {
    const url = new URL(input);
    return url.href;
  } catch (err) {
    const withScheme = `https://${input}`;
    try {
      const url = new URL(withScheme);
      return url.href;
    } catch (err2) {
      return "";
    }
  }
}

async function openUrl(url, mode) {
  const api = getChromeApi();
  const openMode = mode || data.settings.openMode;
  if (api?.tabs && (openMode === "new" || openMode === "background")) {
    api.tabs.create({ url, active: openMode !== "background" });
    return;
  }
  if (openMode === "new") {
    window.open(url, "_blank");
  } else if (openMode === "background") {
    window.open(url, "_blank", "noopener,noreferrer");
  } else {
    window.location.href = url;
  }
}

function setBackground(style) {
  if (!style) return;
  if (style.startsWith("data:") || style.startsWith("http")) {
    elements.background.style.backgroundImage = `url('${style}')`;
  } else {
    elements.background.style.backgroundImage = style;
  }
}

function applyBackgroundOverlay() {
  const type = data?.settings?.backgroundType || "bing";
  const isImage = type === "bing" || type === "custom";
  const strength = Math.min(0.6, Math.max(0, Number(data?.settings?.backgroundOverlayStrength)));
  if (isImage) {
    document.documentElement.style.setProperty("--bg-overlay", `rgba(0, 0, 0, ${strength})`);
    return;
  }
  document.documentElement.style.setProperty("--bg-overlay", "rgba(0, 0, 0, 0)");
}

async function loadBackground() {
  const settings = data.settings;
  elements.background.classList.add("is-loading");

  if (settings.backgroundType === "bing") {
    const info = await getBingWallpaper();
    if (info.dataUrl) {
      setBackground(info.dataUrl);
      if (info.failed) toast("壁纸获取失败，已回退到缓存");
      else if (!info.fromCache) toast("已更新今日 Bing 壁纸");
    } else {
      elements.background.style.background = settings.backgroundColor;
      toast("壁纸获取失败，已使用默认背景");
    }
  } else if (settings.backgroundType === "color") {
    elements.background.style.backgroundImage = "none";
    elements.background.style.background = settings.backgroundColor;
  } else if (settings.backgroundType === "gradient") {
    setBackground(settings.backgroundGradient);
  } else if (settings.backgroundType === "custom") {
    setBackground(settings.backgroundCustom || settings.backgroundColor);
  }

  applyBackgroundOverlay();
  elements.background.classList.remove("is-loading");
}

function pushBackup() {
  if (!data.settings.maxBackups) return;
  const snapshot = createBackupSnapshot(data);
  data.backups.unshift(snapshot);
  if (data.settings.maxBackups > 0 && data.backups.length > data.settings.maxBackups) {
    data.backups = data.backups.slice(0, data.settings.maxBackups);
  }
}

async function persistData() {
  debugLog("persist_start", {
    useSync: data.settings.syncEnabled,
    groups: data.groups?.length || 0,
    nodes: Object.keys(data.nodes || {}).length,
    lastUpdated: data.lastUpdated || 0,
  });
  const useSync = data.settings.syncEnabled;
  const changed = dedupeData(data);
  let warning = null;
  let err = null;
  const err1 = await saveData(data, useSync);
  if (err1) {
    if (err1 === "sync_quota_exceeded" || err1.startsWith("local_trimmed_")) {
      warning = err1;
    } else {
      err = err1;
    }
  }
  if (useSync) {
    await saveData(data, false);
  }
  if (changed) {
    const err2 = await saveData(data, useSync);
    if (useSync) await saveData(data, false);
    if (err2) {
      if (err2 === "sync_quota_exceeded" || err2.startsWith("local_trimmed_")) {
        warning = err2;
      } else {
        err = err2;
      }
    }
    debugLog("persist_dedupe", { changed, err2 });
  }
  if (shouldDebugPersist()) {
    const verify = await loadDataFromArea(false);
    debugLog("persist_verify", {
      groups: verify.groups?.length || 0,
      nodes: Object.keys(verify.nodes || {}).length,
      lastUpdated: verify.lastUpdated || 0,
    });
  }
  debugLog("persist_done", { err1, changed, warning, err });
  return { ok: !err, warning, err };
}

function getActiveGroup() {
  return data.groups.find((g) => g.id === activeGroupId) || data.groups[0];
}

function getCurrentNodes() {
  if (activeGroupId === RECENT_GROUP_ID) return recentItems;
  const group = getActiveGroup();
  const nodeIds = openFolderId ? data.nodes[openFolderId]?.children || [] : group.nodes;
  return nodeIds.map((id) => data.nodes[id]).filter(Boolean);
}

function uniqueNodes(nodes) {
  const seenId = new Set();
  const out = [];
  for (const node of nodes) {
    if (!node?.id) continue;
    if (seenId.has(node.id)) continue;
    seenId.add(node.id);
    out.push(node);
  }
  return out;
}

function renderGroups() {
  elements.groupTabs.innerHTML = "";
  elements.recentTab.classList.toggle("active", activeGroupId === RECENT_GROUP_ID);
  const recentLabel = elements.recentTab.dataset.label || elements.recentTab.textContent || "最近浏览";
  elements.recentTab.dataset.label = recentLabel;
  elements.recentTab.setAttribute("aria-label", recentLabel);
  elements.recentTab.textContent = data.settings.sidebarCollapsed ? "" : recentLabel;
  elements.recentTab.dataset.short = "0";
  data.groups
    .sort((a, b) => a.order - b.order)
    .forEach((group, idx) => {
      const btn = document.createElement("button");
      btn.className = `group-tab draggable ${group.id === activeGroupId ? "active" : ""}`;
      btn.dataset.label = group.name;
      btn.setAttribute("aria-label", group.name);
      btn.textContent = data.settings.sidebarCollapsed ? "" : group.name;
      btn.dataset.short = String(idx + 1);
      btn.draggable = true;
      btn.addEventListener("click", () => {
        activeGroupId = group.id;
        openFolderId = null;
        data.settings.lastActiveGroupId = activeGroupId;
        persistData();
        render();
      });
      btn.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        openGroupContextMenu(e.clientX, e.clientY, group);
      });
      btn.addEventListener("dragstart", () => {
        draggingGroupId = group.id;
        btn.classList.add("dragging");
      });
      btn.addEventListener("dragend", () => {
        draggingGroupId = null;
        btn.classList.remove("dragging");
        qsa(".group-tab", elements.groupTabs).forEach((el) => el.classList.remove("drop-target"));
      });
      btn.addEventListener("dragover", (e) => {
        e.preventDefault();
        btn.classList.add("drop-target");
      });
      btn.addEventListener("dragleave", () => {
        btn.classList.remove("drop-target");
      });
      btn.addEventListener("drop", (e) => {
        e.preventDefault();
        btn.classList.remove("drop-target");
        if (!draggingGroupId || draggingGroupId === group.id) return;
        moveGroupBefore(draggingGroupId, group.id);
      });
      elements.groupTabs.appendChild(btn);
    });
}

async function renderGrid() {
  const seq = ++renderSeq;
  const grid = openFolderId ? elements.folderGrid : elements.grid;
  const nodes = uniqueNodes(getCurrentNodes());
  grid.innerHTML = "";

  const referenceGrid = openFolderId ? elements.grid : grid;
  const width = referenceGrid.getBoundingClientRect().width || referenceGrid.clientWidth || window.innerWidth;
  const density = densityMap[data.settings.gridDensity] || densityMap.standard;
  const gap = density.gap || 16;
  const style = getComputedStyle(referenceGrid);
  const paddingX = (parseFloat(style.paddingLeft) || 0) + (parseFloat(style.paddingRight) || 0);
  const available = Math.max(0, width - paddingX);
  const minTile = 64;
  const maxTile = 220;
  const baseSize = data.settings.lastTileSize || density.size || 96;
  let maxColumns = Math.max(1, Math.floor((available + gap) / (baseSize + gap)));
  let columns = maxColumns;
  if (data.settings.fixedLayout) {
    const desired = Math.max(1, data.settings.fixedCols || 8);
    columns = Math.min(desired, maxColumns);
  }
  let tileSize = baseSize;
  if (columns <= 1 && available > 0) {
    tileSize = Math.max(minTile, Math.min(maxTile, Math.floor(available)));
  } else {
    tileSize = Math.max(minTile, Math.min(maxTile, baseSize));
  }
  const iconRatio = density.icon && density.size ? density.icon / density.size : 0.4;
  let iconSize = Math.max(18, Math.round(tileSize * iconRatio));
  if (!openFolderId) {
    lastMainLayout = { columns, tileSize, iconSize };
  } else if (lastMainLayout) {
    columns = lastMainLayout.columns;
    tileSize = lastMainLayout.tileSize;
    const iconRatioOverride = density.icon && density.size ? density.icon / density.size : 0.4;
    iconSize = Math.max(18, Math.round(tileSize * iconRatioOverride));
  }
  grid.style.setProperty("--tile-size", `${tileSize}px`);
  grid.style.setProperty("--tile-icon", `${iconSize}px`);
  grid.style.gridTemplateColumns = `repeat(${columns}, minmax(${tileSize}px, 1fr))`;

  for (const [idx, node] of nodes.entries()) {
    if (seq !== renderSeq) return;
    const tile = document.createElement("div");
    tile.className = "tile";
    tile.dataset.id = node.id;
    tile.dataset.index = idx;
    tile.draggable = true;
    tile.tabIndex = 0;

    const icon = document.createElement("div");
    icon.className = "tile-icon";
    const img = document.createElement("img");
    img.alt = node.title || node.url || "";
    const iconSrc = await resolveIcon(node, data.settings);
    img.src = iconSrc;
    if (node.url && data.settings.iconFetch && !iconSrc.startsWith("data:")) {
      const candidates = getFaviconCandidates(node.url);
      if (candidates.length) {
        let idx = Math.max(0, candidates.indexOf(iconSrc));
        img.onerror = () => {
          idx += 1;
          if (idx < candidates.length) img.src = candidates[idx];
        };
      }
    }
    if (seq !== renderSeq) return;
    icon.appendChild(img);

    const title = document.createElement("div");
    title.className = "tile-title";
    title.textContent = node.title || node.url || "未命名";

    tile.appendChild(icon);
    tile.appendChild(title);

    if (node.type === "folder") {
      const badge = document.createElement("div");
      badge.className = "tile-badge";
      badge.textContent = `${node.children?.length || 0}`;
      tile.appendChild(badge);
    }

    if (selectedIds.has(node.id)) {
      tile.classList.add("selected");
    }

    tile.addEventListener("click", (e) => {
      if (selectionMode) {
        toggleSelect(node.id, idx, e.shiftKey);
        return;
      }
      if (node.type === "folder") {
        openFolder(node.id);
      } else {
        const url = normalizeUrl(node.url);
        if (!url) {
          toast("URL 无效");
          return;
        }
        openUrl(url);
      }
    });

    tile.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      openContextMenu(e.clientX, e.clientY, node);
    });

    tile.addEventListener("mouseenter", (e) => {
      if (!data.settings.tooltipEnabled) return;
      clearTimeout(tooltipTimer);
      const text = node.type === "folder" ? `${node.title}（文件夹）` : `${node.title}\n${node.url}`;
      tooltipTimer = setTimeout(() => showTooltip(text, e.clientX, e.clientY), 200);
    });
    tile.addEventListener("mouseleave", () => {
      clearTimeout(tooltipTimer);
      hideTooltip();
    });

    tile.addEventListener("dragstart", (e) => {
      dragState = { id: node.id, fromFolder: openFolderId };
      e.dataTransfer.effectAllowed = "move";
    });
    tile.addEventListener("dragover", (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
    });
    tile.addEventListener("drop", (e) => {
      e.preventDefault();
      e.stopPropagation();
      handleDropOnTile(node.id);
    });

    grid.appendChild(tile);
  }

  updateEmptyState();
}

function updateEmptyState() {
  if (activeGroupId === RECENT_GROUP_ID) {
    elements.emptyState.classList.add("hidden");
    return;
  }
  const nodes = getCurrentNodes();
  if (nodes.length === 0 && !data.settings.emptyHintDisabled) {
    elements.emptyState.classList.remove("hidden");
  } else {
    elements.emptyState.classList.add("hidden");
  }
}

function openFolder(folderId) {
  openFolderId = folderId;
  elements.folderOverlay.classList.remove("hidden");
  elements.folderOverlay.setAttribute("aria-hidden", "false");
  elements.folderTitle.textContent = data.nodes[folderId]?.title || "文件夹";
  render();
}

function closeFolder() {
  openFolderId = null;
  elements.folderOverlay.classList.add("hidden");
  elements.folderOverlay.setAttribute("aria-hidden", "true");
  render();
}

function toggleSelect(id, index, range) {
  const nodes = getCurrentNodes();
  if (range && lastSelectedIndex !== null) {
    const start = Math.min(lastSelectedIndex, index);
    const end = Math.max(lastSelectedIndex, index);
    for (let i = start; i <= end; i++) {
      if (nodes[i]) selectedIds.add(nodes[i].id);
    }
  } else {
    if (selectedIds.has(id)) selectedIds.delete(id);
    else selectedIds.add(id);
    lastSelectedIndex = index;
  }
  if (lastSelectedIndex === null && typeof index === "number") {
    lastSelectedIndex = index;
  }
  render();
}

function clearSelection() {
  selectedIds.clear();
  selectionMode = false;
  lastSelectedIndex = null;
  if (selectionBox) {
    selectionBox.remove();
    selectionBox = null;
  }
}

function openContextMenu(x, y, node) {
  elements.contextMenu.innerHTML = "";
  const actions = [];
  if (activeGroupId === RECENT_GROUP_ID && node.type === "history") {
    actions.push({ label: "在本页打开", fn: () => openUrl(normalizeUrl(node.url)) });
    actions.push({ label: "新标签打开", fn: () => openUrl(normalizeUrl(node.url), "new") });
    actions.push({ label: "添加到快捷", fn: () => openAddHistoryToGroup(node) });
  } else if (node.type !== "folder") {
    actions.push({ label: "在本页打开", fn: () => openUrl(normalizeUrl(node.url)) });
    actions.push({ label: "新标签打开", fn: () => openUrl(normalizeUrl(node.url), "new") });
    actions.push({ label: "后台打开", fn: () => openUrl(normalizeUrl(node.url), "background") });
  } else {
    actions.push({ label: "打开文件夹", fn: () => openFolder(node.id) });
    actions.push({ label: "解散文件夹", fn: () => dissolveFolder(node.id) });
  }
  if (node.type !== "history") {
    actions.push({ label: "编辑", fn: () => openEditModal(node) });
    actions.push({ label: "删除", fn: () => deleteNodes([node.id]) });
  }

  for (const action of actions) {
    const btn = document.createElement("button");
    btn.textContent = action.label;
    btn.addEventListener("click", () => {
      action.fn();
      elements.contextMenu.classList.add("hidden");
    });
    elements.contextMenu.appendChild(btn);
  }
  elements.contextMenu.style.left = `${x}px`;
  elements.contextMenu.style.top = `${y}px`;
  elements.contextMenu.classList.remove("hidden");
}

function closeContextMenu() {
  elements.contextMenu.classList.add("hidden");
}

function openGroupContextMenu(x, y, group) {
  elements.contextMenu.innerHTML = "";
  const actions = [
    { label: "重命名", fn: () => renameGroup(group) },
    { label: "删除分组", fn: () => deleteGroup(group) },
  ];
  for (const action of actions) {
    const btn = document.createElement("button");
    btn.textContent = action.label;
    btn.addEventListener("click", () => {
      action.fn();
      elements.contextMenu.classList.add("hidden");
    });
    elements.contextMenu.appendChild(btn);
  }
  elements.contextMenu.style.left = `${x}px`;
  elements.contextMenu.style.top = `${y}px`;
  elements.contextMenu.classList.remove("hidden");
}

function handleDropOnTile(targetId) {
  if (!dragState || dragState.id === targetId) return;
  if (activeGroupId === RECENT_GROUP_ID) return;
  const sourceId = dragState.id;
  const targetNode = data.nodes[targetId];
  const sourceNode = data.nodes[sourceId];
  if (!targetNode || !sourceNode) return;

  if (targetNode.type !== "folder") {
    pushBackup();
    const inFolder = !!openFolderId;
    const container = inFolder ? data.nodes[openFolderId] : getActiveGroup();
    const list = inFolder ? container.children || [] : container.nodes;
    const targetIndex = list.indexOf(targetId);
    const sourceIndex = list.indexOf(sourceId);
    let insertIndex = targetIndex >= 0 ? targetIndex : list.length;
    if (sourceIndex >= 0 && sourceIndex < insertIndex) insertIndex -= 1;

    removeNodeFromLocation(sourceId);
    removeNodeFromLocation(targetId);

    const folderId = `fld_${Date.now()}`;
    const folder = {
      id: folderId,
      type: "folder",
      title: "新建文件夹",
      children: [targetId, sourceId],
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
    data.nodes[folderId] = folder;

    if (inFolder) {
      const next = (container.children || []).filter((nid) => nid !== sourceId && nid !== targetId);
      next.splice(Math.max(0, Math.min(insertIndex, next.length)), 0, folderId);
      container.children = next;
    } else {
      const next = container.nodes.filter((nid) => nid !== sourceId && nid !== targetId);
      next.splice(Math.max(0, Math.min(insertIndex, next.length)), 0, folderId);
      container.nodes = next;
    }
    persistData();
    render();
    toast("已创建文件夹");
    return;
  }

  pushBackup();
  removeNodeFromLocation(sourceId);
  targetNode.children = targetNode.children || [];
  targetNode.children.push(sourceId);
  persistData();
  render();
  toast("已加入文件夹");
}

function dissolveFolder(folderId) {
  const folder = data.nodes[folderId];
  if (!folder || folder.type !== "folder") return;
  pushBackup();
  removeNodeFromLocation(folderId);
  const group = getActiveGroup();
  group.nodes.push(...(folder.children || []));
  delete data.nodes[folderId];
  persistData();
  render();
  toast("已解散文件夹");
}

function removeNodeFromLocation(id) {
  for (const group of data.groups) {
    group.nodes = group.nodes.filter((nid) => nid !== id);
  }
  for (const node of Object.values(data.nodes)) {
    if (node.type === "folder" && Array.isArray(node.children)) {
      node.children = node.children.filter((nid) => nid !== id);
    }
  }
}


function moveNodeInList(list, id, index) {
  const next = list.filter((nid) => nid !== id);
  const safeIndex = Math.max(0, Math.min(index, next.length));
  next.splice(safeIndex, 0, id);
  return next;
}

function dedupeData(input) {
  let changed = false;
  input.nodes = { ...(input.nodes || {}) };

  for (const group of input.groups || []) {
    const uniq = [];
    const set = new Set();
    for (const id of group.nodes || []) {
      if (!input.nodes[id]) {
        changed = true;
        continue;
      }
      if (set.has(id)) {
        changed = true;
        continue;
      }
      set.add(id);
      uniq.push(id);
    }
    group.nodes = uniq;
  }

  for (const node of Object.values(input.nodes)) {
    if (node.type === "folder" && Array.isArray(node.children)) {
      const uniq = [];
      const set = new Set();
      for (const id of node.children) {
        if (!input.nodes[id]) {
          changed = true;
          continue;
        }
        if (set.has(id)) {
          changed = true;
          continue;
        }
        set.add(id);
        uniq.push(id);
      }
      node.children = uniq;
    }
  }

  return changed;
}

function moveGroupBefore(sourceId, targetId) {
  const targetIndex = data.groups
    .sort((a, b) => a.order - b.order)
    .map((g) => g.id)
    .indexOf(targetId);
  moveGroupToIndex(sourceId, targetIndex);
}

function moveGroupToIndex(sourceId, index) {
  const ordered = data.groups.sort((a, b) => a.order - b.order).map((g) => g.id);
  const ids = ordered.filter((id) => id !== sourceId);
  const safeIndex = Math.max(0, Math.min(index, ids.length));
  ids.splice(safeIndex, 0, sourceId);
  ids.forEach((id, idx) => {
    const group = data.groups.find((g) => g.id === id);
    if (group) group.order = idx;
  });
  persistData();
  render();
}

function renameGroup(group) {
  const name = prompt("分组名称", group.name);
  if (!name) return;
  group.name = name.trim();
  persistData();
  render();
}

function deleteGroup(group) {
  if (data.groups.length <= 1) {
    toast("至少保留一个分组");
    return;
  }
  if (!confirm(`删除分组「${group.name}」？`)) return;
  data.groups = data.groups.filter((g) => g.id !== group.id);
  if (activeGroupId === group.id) activeGroupId = data.groups[0].id;
  persistData();
  render();
}

function deleteNodes(ids) {
  if (!ids.length) return;
  if (activeGroupId === RECENT_GROUP_ID) return;
  pushBackup();
  const snapshot = JSON.parse(JSON.stringify(data));

  ids.forEach((id) => {
    removeNodeFromLocation(id);
    delete data.nodes[id];
  });

  pendingDeletion = { snapshot, ids };
  persistData();
  render();

  toast(`已删除 ${ids.length} 个快捷按钮`, "撤销", () => undoDelete());
  setTimeout(() => {
    pendingDeletion = null;
  }, 5000);
}

function undoDelete() {
  if (!pendingDeletion) return;
  data = pendingDeletion.snapshot;
  pendingDeletion = null;
  persistData();
  render();
  toast("已恢复");
}

function openModal(html) {
  elements.modal.innerHTML = html;
  elements.modalOverlay.classList.remove("hidden");
  elements.modalOverlay.setAttribute("aria-hidden", "false");
}

function closeModal() {
  elements.modalOverlay.classList.add("hidden");
  elements.modalOverlay.setAttribute("aria-hidden", "true");
  elements.modal.innerHTML = "";
  settingsOpen = false;
  settingsSaving = false;
  settingsSaveQueued = false;
  settingsSaveNow = null;
  if (settingsSaveTimer) {
    clearTimeout(settingsSaveTimer);
    settingsSaveTimer = null;
  }
  if (pendingStorageReload) {
    pendingStorageReload = false;
    scheduleStorageReload();
  }
}

function openAddModal() {
  const html = `
    <h2>新增快捷按钮</h2>
    <div class="section">
      <label>网址</label>
      <input id="fieldUrl" type="url" placeholder="https://" />
    </div>
    <div class="section">
      <label>标题</label>
      <input id="fieldTitle" type="text" placeholder="可选" />
    </div>
    <div class="section">
      <label>图标来源</label>
      <select id="fieldIconType">
        <option value="auto">自动抓取 favicon</option>
        <option value="upload">上传图标</option>
        <option value="color">颜色头像</option>
        <option value="remote">远程图标 URL</option>
      </select>
    </div>
    <div id="iconExtra" class="section"></div>
    <div class="section">
      <button id="btnFromTab" class="icon-btn">从当前标签页添加</button>
    </div>
    <div class="actions">
      <button id="btnCancel" class="icon-btn">取消</button>
      <button id="btnSave" class="icon-btn">保存</button>
    </div>
  `;
  openModal(html);

  const iconTypeEl = $("fieldIconType");
  const iconExtra = $("iconExtra");

  function renderIconExtra(type) {
    iconExtra.innerHTML = "";
    if (type === "upload") {
      iconExtra.innerHTML = `<label>上传图标</label><input id="fieldUpload" type="file" accept="image/*" />`;
    } else if (type === "color") {
      iconExtra.innerHTML = `<label>头像颜色</label><input id="fieldColor" type="color" value="#4dd6a8" />`;
    } else if (type === "remote") {
      iconExtra.innerHTML = `<label>远程图标 URL</label><input id="fieldRemote" type="url" placeholder="https://" />`;
    }
  }

  renderIconExtra(iconTypeEl.value);
  iconTypeEl.addEventListener("change", () => renderIconExtra(iconTypeEl.value));
  const urlInput = $("fieldUrl");
  if (urlInput) {
    urlInput.focus();
    if (urlInput.select) urlInput.select();
  }

  $("btnFromTab").addEventListener("click", async () => {
    const api = getChromeApi();
    if (!api?.tabs) return;
    api.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      const tab = tabs?.[0];
      if (!tab) return;
      $("fieldUrl").value = tab.url || "";
      $("fieldTitle").value = tab.title || "";
    });
  });

  $("btnCancel").addEventListener("click", closeModal);
  $("btnSave").addEventListener("click", async () => {
    const snapshot = JSON.parse(JSON.stringify(data));
    const url = normalizeUrl($("fieldUrl").value.trim());
    if (!url) {
      toast("URL 不合法");
      return;
    }
    let title = $("fieldTitle").value.trim();
    const titlePending = !title;
    if (!title) title = new URL(url).hostname;
    let iconType = iconTypeEl.value;
    let iconData = "";
    let color = "";

    if (iconType === "upload") {
      const file = $("fieldUpload")?.files?.[0];
      if (file) {
        iconData = await readFileAsDataUrl(file);
      }
    } else if (iconType === "color") {
      color = $("fieldColor").value;
    } else if (iconType === "remote") {
      iconData = $("fieldRemote").value.trim();
    }

    const iconPending = iconType === "auto";
    if (iconType === "auto") {
      iconType = "letter";
    }

    pushBackup();
    const id = `itm_${Date.now()}`;
    data.nodes[id] = {
      id,
      type: "item",
      title,
      url,
      iconType,
      iconData,
      color,
      titlePending,
      iconPending,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };

    if (openFolderId) {
      data.nodes[openFolderId].children.push(id);
    } else {
      const targetGroup = getActiveGroup();
      targetGroup.nodes.push(id);
      if (activeGroupId === RECENT_GROUP_ID) {
        activeGroupId = targetGroup.id;
      }
    }
    data.settings.lastActiveGroupId = getActiveGroup().id;
    debugLog("add_item", {
      id,
      url,
      groupId: openFolderId ? openFolderId : getActiveGroup().id,
      openFolderId: openFolderId || "",
    });
    const result = await persistData();
    if (!result.ok) {
      data = snapshot;
      render();
      toast("保存失败：本地存储空间不足");
      return;
    }
    render();
    closeModal();
    if (titlePending) fetchTitleInBackground(id, url);
    if (iconPending) fetchFaviconInBackground(id, url);
    if (result.warning === "local_trimmed_backups") {
      toast("新增成功（已清理备份以释放空间）");
    } else if (result.warning === "local_trimmed_icons") {
      toast("新增成功（已重置上传图标以释放空间）");
    } else if (result.warning === "local_trimmed_background") {
      toast("新增成功（已清理自定义背景以释放空间）");
    } else if (result.warning === "sync_quota_exceeded") {
      toast("新增成功（同步空间不足，已保存到本地）");
    } else {
      toast("新增成功");
    }
  });
}

function openEditModal(node) {
  const html = `
    <h2>编辑</h2>
    <div class="section">
      <label>标题</label>
      <input id="fieldTitle" type="text" value="${node.title || ""}" />
    </div>
    ${node.type === "item" ? `
    <div class="section">
      <label>网址</label>
      <input id="fieldUrl" type="url" value="${node.url || ""}" />
    </div>
    <div class="section">
      <label>图标来源</label>
      <select id="fieldIconType">
        <option value="auto">自动抓取 favicon</option>
        <option value="upload">上传图标</option>
        <option value="color">颜色头像</option>
        <option value="remote">远程图标 URL</option>
      </select>
    </div>
    <div id="iconExtra" class="section"></div>
    ` : ""}
    <div class="actions">
      <button id="btnCancel" class="icon-btn">取消</button>
      <button id="btnSave" class="icon-btn">保存</button>
    </div>
  `;
  openModal(html);

  if (node.type === "item") {
    const iconTypeEl = $("fieldIconType");
    iconTypeEl.value = node.iconType === "letter" ? "auto" : (node.iconType || "auto");
    const iconExtra = $("iconExtra");
    function renderIconExtra(type) {
      iconExtra.innerHTML = "";
      if (type === "upload") {
        iconExtra.innerHTML = `<label>上传图标</label><input id="fieldUpload" type="file" accept="image/*" />`;
      } else if (type === "color") {
        iconExtra.innerHTML = `<label>头像颜色</label><input id="fieldColor" type="color" value="${node.color || "#4dd6a8"}" />`;
      } else if (type === "remote") {
        iconExtra.innerHTML = `<label>远程图标 URL</label><input id="fieldRemote" type="url" value="${node.iconData || ""}" />`;
      }
    }
    renderIconExtra(iconTypeEl.value);
    iconTypeEl.addEventListener("change", () => renderIconExtra(iconTypeEl.value));
  }

  $("btnCancel").addEventListener("click", closeModal);
  $("btnSave").addEventListener("click", async () => {
    const snapshot = JSON.parse(JSON.stringify(data));
    pushBackup();
    node.title = $("fieldTitle").value.trim() || node.title;
    if (node.type === "item") {
      const url = normalizeUrl($("fieldUrl").value.trim());
      if (!url) {
        toast("URL 不合法");
        return;
      }
      node.url = url;
      const iconType = $("fieldIconType").value;
      node.iconType = iconType;
      if (iconType === "upload") {
        const file = $("fieldUpload")?.files?.[0];
        if (file) node.iconData = await readFileAsDataUrl(file);
      } else if (iconType === "color") {
        node.color = $("fieldColor").value;
        node.iconData = "";
      } else if (iconType === "remote") {
        node.iconData = $("fieldRemote").value.trim();
      } else {
        node.iconData = "";
      }
    }
    node.updatedAt = Date.now();
    const result = await persistData();
    if (!result.ok) {
      data = snapshot;
      render();
      toast("保存失败：本地存储空间不足");
      return;
    }
    render();
    closeModal();
    if (result.warning === "local_trimmed_backups") {
      toast("保存成功（已清理备份以释放空间）");
    } else if (result.warning === "local_trimmed_icons") {
      toast("保存成功（已重置上传图标以释放空间）");
    } else if (result.warning === "local_trimmed_background") {
      toast("保存成功（已清理自定义背景以释放空间）");
    } else if (result.warning === "sync_quota_exceeded") {
      toast("保存成功（同步空间不足，已保存到本地）");
    } else {
      toast("保存成功");
    }
  });
}

function openOpenModeMenu() {
  const modes = [
    { id: "current", label: "当前标签打开" },
    { id: "new", label: "新标签打开" },
    { id: "background", label: "后台新标签打开" },
  ];
  const idx = modes.findIndex((m) => m.id === data.settings.openMode);
  const next = modes[(idx + 1) % modes.length];
  data.settings.openMode = next.id;
  persistData();
  updateOpenModeButton();
  toast(`${next.label}`);
}

function openSettingsModal() {
  settingsOpen = true;
  const html = `
    <h2>设置</h2>
    <div class="section">
      <label><input id="settingShowSearch" type="checkbox"> 显示顶部搜索框</label>
      <div class="row-inline">
        <span class="inline-label">默认搜索引擎</span>
        <select id="settingSearchEnginePreset" class="inline-select">
          <option value="https://www.google.com/search?q=">Google</option>
          <option value="https://www.baidu.com/s?wd=">百度</option>
          <option value="https://www.bing.com/search?q=">Bing</option>
          <option value="https://www.so.com/s?q=">360</option>
          <option value="https://www.yandex.com/search/?text=">Yandex</option>
          <option value="custom">自定义</option>
        </select>
      </div>
      <input id="settingSearchEngine" type="text" placeholder="https://www.bing.com/search?q=" class="inline-text" />
    </div>


    <div class="section">
      <div class="row-inline">
        <label><input id="settingFixedLayout" type="checkbox"> 固定列数</label>
        <div class="inline-field">
          <input id="settingCols" type="number" min="1" />
        </div>
      </div>
      <div class="row-inline">
        <span class="inline-label">卡片间隙</span>
        <label><input type="radio" name="density" value="compact" /> 紧凑</label>
        <label><input type="radio" name="density" value="standard" /> 标准</label>
        <label><input type="radio" name="density" value="spacious" /> 宽松</label>
      </div>
    </div>

    <div class="section">
      <div class="row-inline">
        <span class="inline-label">背景</span>
        <select id="settingBgType" class="inline-select">
          <option value="bing">每日 Bing</option>
          <option value="color">纯色</option>
          <option value="gradient">渐变</option>
          <option value="custom">自定义图片</option>
        </select>
      </div>
      <div id="bgColorWrap">
        
        <input id="settingBgColor" type="color" />
      </div>
      <div id="bgGradientWrap">
        <label>渐变颜色</label>
        <div class="row">
          <input id="settingBgGradientA" type="color" />
          <input id="settingBgGradientB" type="color" />
        </div>
      </div>
      <input id="settingBgGradient" type="hidden" />
      <input id="settingBgFile" type="file" accept="image/*" />
    </div>

    <div class="section">
      <div class="row-inline">
        <span class="inline-label">背景遮罩</span>
        <input id="settingBgOverlay" type="range" min="0" max="0.6" step="0.01" class="inline-range" />
        <span id="settingBgOverlayValue" class="inline-value"></span>
      </div>
    </div>

    <div class="section">
      <label data-tooltip="开启后，鼠标悬停在快捷按钮上会显示标题和网址"><input id="settingTooltip" type="checkbox"> 显示提示</label>
      <label data-tooltip="开启后，可使用键盘进行导航与操作（如方向键移动、回车打开）"><input id="settingKeyboard" type="checkbox"> 启用键盘导航</label>
    </div>

    <div class="section">
      <div class="row-inline">
        <span class="inline-label">主题颜色</span>
        <select id="settingTheme" class="inline-select">
          <option value="system">跟随系统</option>
          <option value="light">浅色</option>
          <option value="dark">深色</option>
        </select>
      </div>
    </div>

    <div class="section">
      <div class="row-inline">
        <span class="inline-label">字体大小</span>
        <input id="settingFontSize" type="number" min="10" max="24" class="inline-number" />
      </div>
    </div>

    <div class="section">
      <div class="row-inline">
        <span class="inline-label">默认保存分组</span>
        <select id="settingDefaultGroupMode" class="inline-select">
          <option value="last">上次添加的分组</option>
          <option value="fixed">固定分组</option>
        </select>
        <select id="settingDefaultGroupId" class="inline-select"></select>
      </div>
    </div>

    <div class="section">
      <label><input id="settingSidebarCollapsed" type="checkbox"> 隐藏左侧分组</label>
    </div>

    <div class="section">
      <label><input id="settingSync" type="checkbox"> 启用同步</label>
      <div class="row-inline">
        <span class="inline-label">最大备份数量（0 表示不备份）</span>
        <input id="settingBackup" type="number" min="0" class="inline-number" />
      </div>
      <div class="row-inline">
        <span class="inline-label">重新获取失败图标（每天）</span>
        <select id="settingIconRetryHour" class="inline-select">
          <option value="">不启用</option>
          <option value="0">00:00</option>
          <option value="1">01:00</option>
          <option value="2">02:00</option>
          <option value="3">03:00</option>
          <option value="4">04:00</option>
          <option value="5">05:00</option>
          <option value="6">06:00</option>
          <option value="7">07:00</option>
          <option value="8">08:00</option>
          <option value="9">09:00</option>
          <option value="10">10:00</option>
          <option value="11">11:00</option>
          <option value="12">12:00</option>
          <option value="13">13:00</option>
          <option value="14">14:00</option>
          <option value="15">15:00</option>
          <option value="16">16:00</option>
          <option value="17">17:00</option>
          <option value="18">18:00</option>
          <option value="19">19:00</option>
          <option value="20">20:00</option>
          <option value="21">21:00</option>
          <option value="22">22:00</option>
          <option value="23">23:00</option>
        </select>
      </div>
    </div>

    <div class="section">
      <button id="btnExport" class="icon-btn">导出 JSON</button>
      <button id="btnImport" class="icon-btn">导入 JSON</button>
      <button id="btnBackupManage" class="icon-btn">备份管理</button>
      <button id="btnClearData" class="icon-btn danger strong-label">清空数据</button>
      <button id="btnClearCards" class="icon-btn danger">清空所有卡片</button>
      <button id="btnRefreshIcons" class="icon-btn">刷新所有图标</button>
    </div>

  `;
  openModal(html);

  $("settingShowSearch").checked = data.settings.showSearch;
  $("settingSearchEngine").value = data.settings.searchEngineUrl;
  const presets = {
    "https://www.google.com/search?q=": "https://www.google.com/search?q=",
    "https://www.baidu.com/s?wd=": "https://www.baidu.com/s?wd=",
    "https://www.bing.com/search?q=": "https://www.bing.com/search?q=",
    "https://www.so.com/s?q=": "https://www.so.com/s?q=",
    "https://www.yandex.com/search/?text=": "https://www.yandex.com/search/?text=",
  };
  const presetValue = presets[data.settings.searchEngineUrl] || "custom";
  $("settingSearchEnginePreset").value = presetValue;
  $("settingSearchEngine").disabled = presetValue !== "custom";
  $("settingFixedLayout").checked = data.settings.fixedLayout;
  $("settingCols").value = data.settings.fixedCols;
  const densityRadios = qsa("input[name='density']", elements.modal);
  densityRadios.forEach((radio) => {
    radio.checked = radio.value === data.settings.gridDensity;
  });
  $("settingBgType").value = data.settings.backgroundType;
  $("settingBgColor").value = data.settings.backgroundColor;
  $("settingBgGradient").value = data.settings.backgroundGradient;
  const match = /linear-gradient\\([^,]+,\\s*([^,]+),\\s*([^\\)]+)\\)/.exec(data.settings.backgroundGradient || "");
  const gA = data.settings.backgroundGradientA || match?.[1]?.trim() || "#1d2a3b";
  const gB = data.settings.backgroundGradientB || match?.[2]?.trim() || "#0b0f14";
  $("settingBgGradientA").value = gA;
  $("settingBgGradientB").value = gB;
  $("settingBgOverlay").value = Number(data.settings.backgroundOverlayStrength ?? 0.08);
  $("settingBgOverlayValue").textContent = `${Math.round(Number($("settingBgOverlay").value) * 100)}%`;
  $("settingTooltip").checked = data.settings.tooltipEnabled;
  $("settingKeyboard").checked = data.settings.keyboardNav;
  $("settingTheme").value = data.settings.theme || "system";
  $("settingFontSize").value = data.settings.fontSize || 13;
  $("settingSync").checked = data.settings.syncEnabled;
  $("settingBackup").value = data.settings.maxBackups;
  const retryHour = data.settings.iconRetryHour ?? (data.settings.iconRetryAtSix ? 18 : "");
  $("settingIconRetryHour").value = retryHour === "" ? "" : String(retryHour);
  $("settingSidebarCollapsed").checked = data.settings.sidebarHidden;
  $("settingSidebarCollapsed").addEventListener("change", (e) => {
    data.settings.sidebarHidden = e.target.checked;
    applySidebarState();
  });

  const defaultGroupMode = $("settingDefaultGroupMode");
  const defaultGroupId = $("settingDefaultGroupId");
  defaultGroupMode.value = data.settings.defaultGroupMode || "last";
  defaultGroupId.innerHTML = "";
  data.groups
    .sort((a, b) => a.order - b.order)
    .forEach((g) => {
      const opt = document.createElement("option");
      opt.value = g.id;
      opt.textContent = g.name;
      defaultGroupId.appendChild(opt);
    });
  if (data.settings.defaultGroupId) defaultGroupId.value = data.settings.defaultGroupId;
  const updateDefaultGroupControls = () => {
    const isFixed = defaultGroupMode.value === "fixed";
    defaultGroupId.classList.toggle("hidden", !isFixed);
    defaultGroupId.disabled = !isFixed;
  };
  defaultGroupMode.addEventListener("change", updateDefaultGroupControls);
  updateDefaultGroupControls();

  $("settingSearchEnginePreset").addEventListener("change", (e) => {
    const val = e.target.value;
    if (val === "custom") {
      $("settingSearchEngine").disabled = false;
      $("settingSearchEngine").focus();
    } else {
      $("settingSearchEngine").value = val;
      $("settingSearchEngine").disabled = true;
    }
  });

  $("btnExport").addEventListener("click", () => openExportModal());
  $("btnImport").addEventListener("click", () => openImportModal());
  $("btnBackupManage").addEventListener("click", () => openBackupModal());
  $("btnClearData").addEventListener("click", async () => {
    if (!confirm("确认清空全部数据？")) return;
    data = defaultData();
    activeGroupId = data.groups[0].id;
    await clearData(data.settings.syncEnabled);
    await persistData();
    closeModal();
    render();
    toast("已清空");
  });
  $("btnClearCards").addEventListener("click", async () => {
    if (!confirm("确认清空所有卡片？（分组与设置将保留）")) return;
    pushBackup();
    data.nodes = {};
    data.groups.forEach((g) => {
      g.nodes = [];
    });
    await persistData();
    closeModal();
    render();
    toast("已清空所有卡片");
  });
  $("btnRefreshIcons").addEventListener("click", async () => {
    await refreshAllIcons(Object.values(data.nodes));
    toast("图标刷新完成");
  });

  const saveSettings = async ({ close = false, toastOnSave = false } = {}) => {
    if (settingsSaving) {
      settingsSaveQueued = true;
      return;
    }
    settingsSaving = true;
    qsa(".group-name", elements.modal).forEach((input) => {
      const row = input.closest("[data-group]");
      const id = row.dataset.group;
      const group = data.groups.find((g) => g.id === id);
      if (group) group.name = input.value.trim() || group.name;
    });

    data.settings.showSearch = $("settingShowSearch").checked;
    data.settings.enableSearchEngine = true;
    data.settings.searchEngineUrl = $("settingSearchEngine").value.trim() || data.settings.searchEngineUrl;
    data.settings.fixedLayout = $("settingFixedLayout").checked;
    data.settings.fixedCols = Number($("settingCols").value) || 8;
    const selectedDensity = qsa("input[name='density']", elements.modal).find((r) => r.checked);
    data.settings.gridDensity = selectedDensity ? selectedDensity.value : data.settings.gridDensity;
    data.settings.backgroundType = $("settingBgType").value;
    data.settings.backgroundColor = $("settingBgColor").value;
    const gA = $("settingBgGradientA").value || "#1d2a3b";
    const gB = $("settingBgGradientB").value || "#0b0f14";
    data.settings.backgroundGradientA = gA;
    data.settings.backgroundGradientB = gB;
    data.settings.backgroundGradient = `linear-gradient(120deg, ${gA}, ${gB})`;
    data.settings.backgroundOverlayStrength = Number($("settingBgOverlay").value);
    data.settings.tooltipEnabled = $("settingTooltip").checked;
    data.settings.keyboardNav = $("settingKeyboard").checked;
    data.settings.fontSize = Number($("settingFontSize").value) || data.settings.fontSize;
    data.settings.theme = $("settingTheme").value;
    data.settings.defaultGroupMode = $("settingDefaultGroupMode").value;
    data.settings.defaultGroupId = $("settingDefaultGroupId").value;
    data.settings.sidebarHidden = $("settingSidebarCollapsed").checked;
    data.settings.syncEnabled = $("settingSync").checked;
    const nextMaxBackups = Number($("settingBackup").value) || 0;
    if (nextMaxBackups > 0 && data.backups.length > nextMaxBackups) {
      data.backups = data.backups.slice(0, nextMaxBackups);
    }
    data.settings.maxBackups = nextMaxBackups;
    const retryVal = $("settingIconRetryHour").value;
    if (retryVal === "") {
      data.settings.iconRetryHour = "";
      data.settings.iconRetryAtSix = false;
    } else {
      data.settings.iconRetryHour = Number(retryVal);
      data.settings.iconRetryAtSix = Number(retryVal) === 18;
    }

    const bgFile = $("settingBgFile").files?.[0];
    if (bgFile) {
      data.settings.backgroundCustom = await readFileAsDataUrl(bgFile);
    }

    applyDensity();
    applyTheme();
    await persistData();
    await loadBackground();
    render();
    if (toastOnSave) toast("设置已保存");
    if (close) closeModal();
    settingsSaving = false;
    if (settingsSaveQueued) {
      settingsSaveQueued = false;
      saveSettings({ close: false, toastOnSave: false });
      return;
    }
    return;
  };
  settingsSaveNow = saveSettings;

  const scheduleSettingsSave = (immediate = false) => {
    if (settingsSaveTimer) clearTimeout(settingsSaveTimer);
    const delay = immediate ? 0 : 120;
    settingsSaveTimer = setTimeout(() => {
      settingsSaveTimer = null;
      saveSettings({ close: false, toastOnSave: false });
    }, delay);
  };

  const updateBgControls = (triggerSave = true) => {
    const type = $("settingBgType").value;
    $("bgColorWrap").classList.toggle("hidden", type !== "color");
    $("bgGradientWrap").classList.toggle("hidden", type !== "gradient");
    const bgFile = $("settingBgFile");
    bgFile.classList.toggle("hidden", type !== "custom");
    bgFile.disabled = type !== "custom";
    if (triggerSave) scheduleSettingsSave();
  };
  $("settingBgType").addEventListener("change", () => updateBgControls(true));
  updateBgControls(false);

  qsa("input, select, textarea", elements.modal).forEach((el) => {
    const type = el.getAttribute("type") || "";
    const useInput = type === "text" || type === "url" || type === "number" || type === "color" || type === "range";
    const eventName = useInput ? "input" : "change";
    el.addEventListener(eventName, () => scheduleSettingsSave(useInput));
  });
  $("settingBgFile").addEventListener("change", () => scheduleSettingsSave(true));
  $("settingBgOverlay").addEventListener("input", () => {
    $("settingBgOverlayValue").textContent = `${Math.round(Number($("settingBgOverlay").value) * 100)}%`;
  });
}

function openExportModal() {
  const payload = JSON.stringify(data, null, 2);
  const html = `
    <h2>导出 JSON</h2>
    <div class="section">
      <textarea readonly>${payload}</textarea>
    </div>
    <div class="actions">
      <button id="btnCopy" class="icon-btn">复制</button>
      <button id="btnClose" class="icon-btn">关闭</button>
    </div>
  `;
  openModal(html);
  $("btnCopy").addEventListener("click", async () => {
    await navigator.clipboard.writeText(payload);
    toast("已复制");
  });
  $("btnClose").addEventListener("click", closeModal);
}

function openImportModal() {
  const html = `
    <h2>导入 JSON</h2>
    <div class="section">
      <label>导入策略</label>
      <select id="importMode">
        <option value="replace">覆盖所有</option>
        <option value="merge">合并现有</option>
        <option value="add">仅新增不覆盖</option>
      </select>
    </div>
    <div class="section">
      <textarea id="importText" placeholder="粘贴 JSON"></textarea>
    </div>
    <div class="actions">
      <button id="btnCancel" class="icon-btn">取消</button>
      <button id="btnImportNow" class="icon-btn">导入</button>
    </div>
  `;
  openModal(html);
  $("btnCancel").addEventListener("click", closeModal);
  $("btnImportNow").addEventListener("click", async () => {
    try {
      const incoming = JSON.parse($("importText").value.trim());
      const mode = $("importMode").value;
      if (!incoming.schemaVersion) throw new Error("无 schemaVersion");
      pushBackup();
      if (mode === "replace") {
        data = incoming;
      } else if (mode === "merge") {
        data.groups = [...data.groups, ...incoming.groups];
        data.nodes = { ...data.nodes, ...incoming.nodes };
      } else if (mode === "add") {
        for (const [id, node] of Object.entries(incoming.nodes || {})) {
          if (!data.nodes[id]) data.nodes[id] = node;
        }
        data.groups = [...data.groups, ...incoming.groups.filter((g) => !data.groups.find((x) => x.id === g.id))];
      }
      await persistData();
      closeModal();
      render();
      toast("导入成功");
    } catch (err) {
      toast(`导入失败：${err.message}`);
    }
  });
}

function openBackupModal() {
  const list = data.backups
    .map((b) => `<div class="row" data-backup="${b.id}"><div>${new Date(b.ts).toLocaleString()}</div><div class="row-actions"><button class="icon-btn backup-restore">恢复</button><button class="icon-btn backup-delete">删除</button></div></div>`)
    .join("");
  const html = `
    <h2>备份管理</h2>
    <div class="section">${list || "暂无备份"}</div>
    <div class="actions"><button id="btnClose" class="icon-btn">关闭</button></div>
  `;
  openModal(html);
  qsa(".backup-restore", elements.modal).forEach((btn) => {
    btn.addEventListener("click", () => {
      const row = btn.closest("[data-backup]");
      const backup = data.backups.find((b) => b.id === row.dataset.backup);
      if (!backup) return;
      data = backup.data;
      persistData();
      closeModal();
      render();
      toast("已恢复备份");
    });
  });
  qsa(".backup-delete", elements.modal).forEach((btn) => {
    btn.addEventListener("click", () => {
      const row = btn.closest("[data-backup]");
      if (!row) return;
      const id = row.dataset.backup;
      if (!id) return;
      data.backups = (data.backups || []).filter((b) => b.id !== id);
      persistData();
      openBackupModal();
      toast("已删除备份");
    });
  });
  $("btnClose").addEventListener("click", closeModal);
}

function readFileAsDataUrl(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

function probeImage(url, timeoutMs = 6000) {
  return new Promise((resolve) => {
    let done = false;
    const img = new Image();
    const timer = setTimeout(() => finish(false), timeoutMs);
    const finish = (ok) => {
      if (done) return;
      done = true;
      clearTimeout(timer);
      img.onload = null;
      img.onerror = null;
      resolve(ok);
    };
    img.onload = () => finish(true);
    img.onerror = () => finish(false);
    img.src = url;
  });
}

async function fetchTitleInBackground(nodeId, url) {
  const title = await fetchTitleViaTab(url);
  if (!title) return;
  const target = data?.nodes?.[nodeId];
  if (!target || !target.titlePending) return;
  target.title = title;
  target.titlePending = false;
  await persistData();
  render();
}

async function fetchFaviconInBackground(nodeId, url) {
  if (!data?.settings?.iconFetch) return;
  const candidates = getFaviconCandidates(url);
  if (!candidates.length) return;
  const cache = await loadIconCache();
  const siteKey = getSiteKey(url);
  for (const candidate of candidates) {
    const ok = await probeImage(candidate);
    if (!ok) continue;
    cache[url] = { url: candidate, ts: Date.now() };
    if (siteKey) cache[siteKey] = { url: candidate, ts: Date.now() };
    await saveIconCache(cache);
    const target = data?.nodes?.[nodeId];
    if (target) target.iconPending = false;
    await persistData();
    render();
    return;
  }
  const target = data?.nodes?.[nodeId];
  if (target) {
    target.iconPending = false;
    await persistData();
    render();
  }
}

async function fetchTitleViaTab(url) {
  const api = getChromeApi();
  if (!api?.tabs) return "";
  return new Promise((resolve) => {
    api.tabs.create({ url, active: false }, (tab) => {
      if (!tab?.id) return resolve("");
      const tabId = tab.id;
      const timeout = setTimeout(() => finish(""), 6000);
      const finish = (title) => {
        clearTimeout(timeout);
        api.tabs.onUpdated.removeListener(onUpdated);
        api.tabs.remove(tabId, () => resolve(title || ""));
      };
      const onUpdated = (id, info, updatedTab) => {
        if (id === tabId && info.status === "complete") {
          finish(updatedTab?.title || "");
        }
      };
      api.tabs.onUpdated.addListener(onUpdated);
    });
  });
}

async function loadRecentHistory() {
  const api = getChromeApi();
  if (!api?.history?.search) return [];
  const startTime = Date.now() - 7 * 24 * 60 * 60 * 1000;
  try {
    const result = api.history.search({ text: "", startTime, maxResults: RECENT_LIMIT });
    const items = typeof result?.then === "function" ? await result : await new Promise((resolve) => {
      api.history.search({ text: "", startTime, maxResults: RECENT_LIMIT }, (res) => resolve(res || []));
    });
    const seen = new Set();
    return (items || [])
      .filter((item) => item.url)
      .filter((item) => {
        let norm = item.url;
        try { norm = new URL(item.url).href; } catch {}
        if (seen.has(norm)) return false;
        seen.add(norm);
        return true;
      })
      .map((item, idx) => ({
        id: `recent_${idx}`,
        type: "history",
        title: item.title || item.url,
        url: item.url,
      }));
  } catch (err) {
    return [];
  }
}

async function addHistoryToShortcuts(node) {
  if (!node?.url) return;
  const targetGroupId = getPreferredGroupIdForNewItem();
  if (!targetGroupId) {
    toast("没有可用分组");
    return;
  }
  return addHistoryToShortcutsInGroup(node, targetGroupId);
}

function getPreferredGroupIdForNewItem() {
  if (data.settings.defaultGroupMode === "fixed" && data.settings.defaultGroupId) {
    const fixed = data.groups.find((g) => g.id === data.settings.defaultGroupId);
    if (fixed) return fixed.id;
  }
  if (data.settings.lastActiveGroupId && data.settings.lastActiveGroupId !== RECENT_GROUP_ID) {
    const last = data.groups.find((g) => g.id === data.settings.lastActiveGroupId);
    if (last) return last.id;
  }
  return data.groups?.[0]?.id || "";
}

function openAddHistoryToGroup(node) {
  if (!node?.url) return;
  if (!data.groups?.length) {
    toast("没有可用分组");
    return;
  }
  const options = data.groups
    .sort((a, b) => a.order - b.order)
    .map((g) => `<option value="${g.id}">${g.name}</option>`)
    .join("");
  const html = `
    <h2>添加到快捷</h2>
    <div class="section">
      <label>选择分组</label>
      <select id="addHistoryGroup">${options}</select>
    </div>
    <div class="actions">
      <button id="btnAddHistoryCancel" class="icon-btn">取消</button>
      <button id="btnAddHistorySave" class="icon-btn">保存</button>
    </div>
  `;
  openModal(html);
  const preferred = getPreferredGroupIdForNewItem();
  if (preferred) $("addHistoryGroup").value = preferred;
  $("btnAddHistoryCancel").addEventListener("click", closeModal);
  $("btnAddHistorySave").addEventListener("click", async () => {
    const groupId = $("addHistoryGroup").value;
    await addHistoryToShortcutsInGroup(node, groupId);
    closeModal();
  });
}

async function addHistoryToShortcutsInGroup(node, groupId) {
  if (!node?.url) return;
  const targetGroup = data.groups.find((g) => g.id === groupId);
  if (!targetGroup) {
    toast("分组不存在");
    return;
  }
  pushBackup();
  const id = `itm_${Date.now()}`;
  data.nodes[id] = {
    id,
    type: "item",
    title: node.title || new URL(node.url).hostname,
    url: node.url,
    iconType: "auto",
    iconData: "",
    color: "",
    createdAt: Date.now(),
    updatedAt: Date.now(),
  };
  targetGroup.nodes.push(id);
  await persistData();
  render();
  toast("已添加到快捷");
}

function handleSearchInput() {
  const query = elements.topSearch.value.trim().toLowerCase();
  if (!query) {
    render();
    return;
  }
  const grid = openFolderId ? elements.folderGrid : elements.grid;
  qsa(".tile", grid).forEach((tile) => {
    const node = data.nodes[tile.dataset.id];
    const text = `${node.title || ""} ${node.url || ""}`.toLowerCase();
    tile.style.display = text.includes(query) ? "" : "none";
  });
}

function ensureSelectionBox() {
  if (!selectionBox) {
    selectionBox = document.createElement("div");
    selectionBox.className = "selection-box hidden";
    document.body.appendChild(selectionBox);
  }
}

function updateSelectionBox(x1, y1, x2, y2) {
  const left = Math.min(x1, x2);
  const top = Math.min(y1, y2);
  const width = Math.abs(x1 - x2);
  const height = Math.abs(y1 - y2);
  selectionBox.style.left = `${left}px`;
  selectionBox.style.top = `${top}px`;
  selectionBox.style.width = `${width}px`;
  selectionBox.style.height = `${height}px`;
  selectionBox.classList.remove("hidden");
}

function selectTilesInBox(grid, x1, y1, x2, y2) {
  const left = Math.min(x1, x2);
  const right = Math.max(x1, x2);
  const top = Math.min(y1, y2);
  const bottom = Math.max(y1, y2);
  qsa(".tile", grid).forEach((tile) => {
    const rect = tile.getBoundingClientRect();
    const hit = rect.left < right && rect.right > left && rect.top < bottom && rect.bottom > top;
    if (hit) selectedIds.add(tile.dataset.id);
  });
}

function getDropIndex(grid, x, y) {
  const tiles = qsa(".tile", grid);
  for (let i = 0; i < tiles.length; i++) {
    const rect = tiles[i].getBoundingClientRect();
    if (y < rect.top + rect.height / 2) return i;
  }
  return tiles.length;
}

async function init() {
  debugLog("init_start", getRuntimeInfo());
  attachStorageListener();
  const localData = await loadData();
  debugLog("init_local", {
    groups: localData.groups?.length || 0,
    nodes: Object.keys(localData.nodes || {}).length,
    lastUpdated: localData.lastUpdated || 0,
    syncEnabled: !!localData.settings?.syncEnabled,
  });
  if (localData.settings.syncEnabled) {
    const syncData = await loadDataFromArea(true);
    if (syncData && syncData.groups?.length) {
      const localTs = Number(localData.lastUpdated || 0);
      const syncTs = Number(syncData.lastUpdated || 0);
      data = syncTs >= localTs ? syncData : localData;
      if (data === localData) {
        await saveData(localData, true);
      }
    } else {
      data = localData;
    }
  } else {
    data = localData;
  }
  const deduped = dedupeData(data);
  if (deduped) {
    await saveData(data, data.settings.syncEnabled);
    if (data.settings.syncEnabled) await saveData(data, false);
  }
  debugLog("init_ready", {
    groups: data.groups?.length || 0,
    nodes: Object.keys(data.nodes || {}).length,
    lastUpdated: data.lastUpdated || 0,
    deduped,
    activeGroupId,
  });
  const preferredGroupId = data.settings.lastActiveGroupId;
  if (preferredGroupId === RECENT_GROUP_ID) {
    activeGroupId = RECENT_GROUP_ID;
  } else if (preferredGroupId && data.groups.find((g) => g.id === preferredGroupId)) {
    activeGroupId = preferredGroupId;
  } else {
    activeGroupId = data.groups?.[0]?.id || RECENT_GROUP_ID;
    data.settings.lastActiveGroupId = activeGroupId;
  }
  recentItems = await loadRecentHistory();
  applyDensity();
  applyTheme();
  applySidebarState();
  closeModal();
  closeFolder();
  await loadBackground();
  await retryFailedIconsIfDue(data.settings);
  render();
}

function render() {
  renderGroups();
  renderGrid();
  elements.topSearchWrap.classList.toggle("hidden", !data.settings.showSearch);
  elements.emptyHintToggle.checked = data.settings.emptyHintDisabled;
  elements.btnSelectAll.classList.toggle("hidden", !selectionMode);
  elements.btnBatchDelete.textContent = selectionMode ? "删除" : "批量删除";
  updateOpenModeButton();
}

function updateOpenModeButton() {
  const map = {
    current: "当前标签打开",
    new: "新标签打开",
    background: "后台新标签打开",
  };
  const label = map[data.settings.openMode] || "当前标签打开";
  elements.btnOpenMode.textContent = `${label}`;
}

function bindEvents() {
  window.addEventListener("resize", () => render());

  elements.btnAdd.addEventListener("click", openAddModal);
  elements.btnFolderAdd.addEventListener("click", openAddModal);
  elements.btnToggleSidebar?.addEventListener("click", () => {
    data.settings.sidebarCollapsed = !data.settings.sidebarCollapsed;
    applySidebarState();
    persistData();
  });
  elements.recentTab.addEventListener("click", async () => {
    activeGroupId = RECENT_GROUP_ID;
    openFolderId = null;
    data.settings.lastActiveGroupId = activeGroupId;
    persistData();
    recentItems = await loadRecentHistory();
    render();
  });
  elements.btnAddGroup.addEventListener("click", () => {
    const groupId = `grp_${Date.now()}`;
    data.groups.push({ id: groupId, name: "新分组", order: data.groups.length, nodes: [] });
    activeGroupId = groupId;
    data.settings.lastActiveGroupId = activeGroupId;
    persistData();
    render();
  });

  elements.btnBatchDelete.addEventListener("click", () => {
    if (activeGroupId === RECENT_GROUP_ID) {
      toast("最近浏览不可批量删除");
      return;
    }
    if (!selectionMode) {
      selectionMode = true;
      toast("进入批量选择模式");
      render();
      return;
    }
    const ids = Array.from(selectedIds);
    if (!ids.length) {
      clearSelection();
      render();
      return;
    }
    deleteNodes(ids);
    clearSelection();
    render();
  });

  elements.btnFolderBatchDelete.addEventListener("click", () => {
    if (activeGroupId === RECENT_GROUP_ID) {
      toast("最近浏览不可批量删除");
      return;
    }
    if (!selectionMode) {
      selectionMode = true;
      toast("进入批量选择模式");
      render();
      return;
    }
    const ids = Array.from(selectedIds);
    if (!ids.length) {
      clearSelection();
      render();
      return;
    }
    deleteNodes(ids);
    clearSelection();
    render();
  });

  elements.btnSelectAll.addEventListener("click", () => {
    if (!selectionMode) return;
    const grid = openFolderId ? elements.folderGrid : elements.grid;
    qsa(".tile", grid).forEach((tile) => selectedIds.add(tile.dataset.id));
    render();
  });

  elements.main?.addEventListener?.("click", (e) => {
    if (suppressBlankClick) {
      suppressBlankClick = false;
      return;
    }
    if (!selectionMode || boxSelecting) return;
    if (e.target.closest(".tile")) return;
    clearSelection();
    render();
  });

  elements.btnOpenMode.addEventListener("click", openOpenModeMenu);
  elements.btnSettings.addEventListener("click", async () => {
    if (settingsOpen) {
      if (settingsSaveTimer) {
        clearTimeout(settingsSaveTimer);
        settingsSaveTimer = null;
      }
      if (typeof settingsSaveNow === "function") {
        await settingsSaveNow({ close: true, toastOnSave: false });
      } else {
        closeModal();
      }
      return;
    }
    openSettingsModal();
  });
  elements.btnSearch.addEventListener("click", () => {
    const query = elements.topSearch.value.trim();
    if (!query) {
      elements.topSearch.focus();
      return;
    }
    openUrl(`${data.settings.searchEngineUrl}${encodeURIComponent(query)}`, "new");
  });

  elements.topSearch.addEventListener("input", handleSearchInput);
  elements.topSearch.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      const query = elements.topSearch.value.trim();
      if (!query) return;
      openUrl(`${data.settings.searchEngineUrl}${encodeURIComponent(query)}`, "new");
    }
  });

  elements.topSearch.addEventListener("focus", async () => {
    if (activeGroupId === RECENT_GROUP_ID) {
      recentItems = await loadRecentHistory();
      render();
    }
  });

  elements.emptyHintToggle.addEventListener("change", async (e) => {
    data.settings.emptyHintDisabled = e.target.checked;
    await persistData();
    render();
  });

  elements.btnCloseFolder.addEventListener("click", closeFolder);
  elements.folderOverlay.addEventListener("click", (e) => {
    if (e.target.closest(".tile")) return;
    if (e.target.closest(".overlay-header")) return;
    closeFolder();
  });

  elements.modalOverlay.addEventListener("click", async (e) => {
    if (e.target !== elements.modalOverlay) return;
    if (settingsOpen) {
      if (settingsSaveTimer) {
        clearTimeout(settingsSaveTimer);
        settingsSaveTimer = null;
      }
      if (typeof settingsSaveNow === "function") {
        await settingsSaveNow({ close: true, toastOnSave: false });
      } else {
        closeModal();
      }
      return;
    }
    closeModal();
  });

  const handleBoxSelectStart = (e, grid) => {
    if (e.button !== 0) return;
    if (e.target.closest(".tile")) return;
    if (!selectionMode) return;
    boxSelecting = true;
    isDraggingBox = false;
    ensureSelectionBox();
    selectionStart = { x: e.clientX, y: e.clientY, grid };
    updateSelectionBox(e.clientX, e.clientY, e.clientX, e.clientY);
  };

  const handleBoxSelectMove = (e) => {
    if (!boxSelecting || !selectionStart) return;
    const dx = Math.abs(e.clientX - selectionStart.x);
    const dy = Math.abs(e.clientY - selectionStart.y);
    if (dx + dy > 6) isDraggingBox = true;
    updateSelectionBox(selectionStart.x, selectionStart.y, e.clientX, e.clientY);
  };

  const handleBoxSelectEnd = (e) => {
    if (!boxSelecting || !selectionStart) return;
    if (isDraggingBox) {
      selectTilesInBox(selectionStart.grid, selectionStart.x, selectionStart.y, e.clientX, e.clientY);
      suppressBlankClick = true;
    }
    boxSelecting = false;
    selectionStart = null;
    isDraggingBox = false;
    if (selectionBox) selectionBox.classList.add("hidden");
    render();
  };

  elements.grid.addEventListener("mousedown", (e) => handleBoxSelectStart(e, elements.grid));
  elements.folderGrid.addEventListener("mousedown", (e) => handleBoxSelectStart(e, elements.folderGrid));
  elements.main?.addEventListener?.("mousedown", (e) => {
    if (openFolderId) return;
    handleBoxSelectStart(e, elements.grid);
  });
  document.addEventListener("mousemove", handleBoxSelectMove);
  document.addEventListener("mouseup", handleBoxSelectEnd);

  document.addEventListener("click", (e) => {
    if (!elements.contextMenu.contains(e.target)) closeContextMenu();
  });

  document.addEventListener("mousemove", (e) => {
    if (!elements.tooltip.classList.contains("hidden")) {
      elements.tooltip.style.left = `${e.clientX + 12}px`;
      elements.tooltip.style.top = `${e.clientY + 12}px`;
    }
  });

  document.addEventListener("mouseover", (e) => {
    const target = e.target.closest("[data-tooltip]");
    if (!target) return;
    const text = target.getAttribute("data-tooltip");
    if (text) showTooltip(text, e.clientX, e.clientY);
  });

  document.addEventListener("mouseout", (e) => {
    const target = e.target.closest("[data-tooltip]");
    if (!target) return;
    hideTooltip();
  });

  document.addEventListener("keydown", (e) => {
    if (!data.settings.keyboardNav) return;
    if (e.key === "Escape" && openFolderId) closeFolder();
    if (e.key === "/") {
      elements.topSearch.focus();
      e.preventDefault();
    }
  });

  elements.grid.addEventListener("dragover", (e) => e.preventDefault());
  elements.grid.addEventListener("drop", (e) => {
    e.preventDefault();
    if (!dragState) return;
    if (activeGroupId === RECENT_GROUP_ID) return;
    const sourceId = dragState.id;
    if (openFolderId) return;
    const group = getActiveGroup();
    const index = getDropIndex(elements.grid, e.clientX, e.clientY);
    group.nodes = moveNodeInList(group.nodes, sourceId, index);
    persistData();
    render();
  });

  elements.folderGrid.addEventListener("dragover", (e) => e.preventDefault());
  elements.folderGrid.addEventListener("drop", (e) => {
    e.preventDefault();
    if (!dragState || !openFolderId) return;
    const sourceId = dragState.id;
    const folder = data.nodes[openFolderId];
    const index = getDropIndex(elements.folderGrid, e.clientX, e.clientY);
    folder.children = moveNodeInList(folder.children || [], sourceId, index);
    persistData();
    render();
  });

  elements.groupTabs.addEventListener("dragover", (e) => {
    if (!draggingGroupId) return;
    e.preventDefault();
    const rect = elements.groupTabs.getBoundingClientRect();
    const edge = 24;
    if (e.clientY < rect.top + edge) {
      elements.groupTabs.scrollTop -= 16;
    } else if (e.clientY > rect.bottom - edge) {
      elements.groupTabs.scrollTop += 16;
    }
  });

  elements.groupTabs.addEventListener("drop", (e) => {
    if (!draggingGroupId) return;
    e.preventDefault();
    const rect = elements.groupTabs.getBoundingClientRect();
    const edge = 24;
    const total = data.groups.length;
    if (e.clientY < rect.top + edge) {
      moveGroupToIndex(draggingGroupId, 0);
    } else if (e.clientY > rect.bottom - edge) {
      moveGroupToIndex(draggingGroupId, total);
    }
    qsa(".group-tab", elements.groupTabs).forEach((el) => el.classList.remove("drop-target"));
  });
}

init();
bindEvents();


</script>
</body>
</html>
