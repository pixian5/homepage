我做了个书签插件，帮我想个解决合并备份的办法：
例如刚开始浏览器1和浏览器2的书签完全一样。
1点在浏览器1删除了书签1,增加了书签2，2点在浏览器2增加了书签1、3,删除了书签4，3点我把浏览器1和2数据进行了备份，把2导入到1，我希望恢复备份能按照时间顺序操作，即虽然浏览器1增加了书签1/2/3，删除了4
这个需求本质上是：**不要“按最终快照覆盖/简单去重”，而是要把两端的变更当成“操作日志”，按时间顺序重放**。这样才能得到例子里想要的结果：最终 **1/2/3 都在，4 被删**（因为 2 点在浏览器2“又加回了 1”，它发生在 1 点删 1 之后）。

---

## 方案：操作日志 + Tombstone（删除墓碑）+ 可重放合并

### 1）数据模型

给每个书签/文件夹一个稳定的 `uuid`（不要用路径/标题/URL 当主键）：

* `nodeId`：UUID（书签或文件夹）
* `type`：bookmark/folder
* `parentId`：父文件夹 UUID
* `position`：排序位置（可用浮点/分数位置，或插入序号）
* `title/url/icon...`

每一次变更都写一条**操作记录**（event/op）：

```json
{
  "opId": "deviceA:000123",      // 全局唯一（deviceId + 单调递增序号）
  "deviceId": "deviceA",
  "seq": 123,                    // 单调递增
  "ts": 1700000000000,           // 毫秒时间戳（可用本地时间；更强可加 HLC）
  "op": "ADD|UPDATE|MOVE|DELETE",
  "nodeId": "uuid-of-node",
  "payload": { ... }             // ADD/UPDATE/MOVE 需要
}
```

删除不要真的“消失”，而是写 `DELETE`，并在本地索引里留下墓碑：

* `tombstone[nodeId] = {deletedAt: ts, opId}`

> **墓碑的意义**：避免“某端删了，另一端导入旧快照又把它复活”。

---

### 2）合并算法（核心）

当你把浏览器2备份导入浏览器1时，做的是：

1. 读取双方的 `ops`（或从备份里读到的 ops）
2. **合并去重**：用 `opId` 去重（同一条操作不会重复执行）
3. **排序并重放**：按“时间顺序”执行

   * 主序：`ts`
   * 次序：`deviceId`（稳定排序用）
   * 末序：`seq` 或 `opId`（保证同设备内顺序不乱）

重放时的规则：

* `DELETE(nodeId)`：写墓碑，并把节点标记删除
* `ADD(nodeId)`：

  * 若存在墓碑且 `墓碑.deletedAt > ADD.ts`：忽略（被更晚删除覆盖）
  * 若存在墓碑但 `ADD.ts > deletedAt`：允许“复活/重新创建”（因为这是更晚发生的 add）
* `UPDATE/MOVE`：

  * 若节点当前被删除且墓碑时间更晚：忽略
  * 否则按 LWW（Last Write Wins）更新字段/父子关系/位置

---

### 3）你的例子用这个方案会得到什么？

初始：浏览器1=浏览器2

1点（浏览器1）：

* DELETE(书签1) @ t=1
* ADD(书签2) @ t=1

2点（浏览器2）：

* ADD(书签1) @ t=2（注意：这里的“书签1”要么是复活同一个 nodeId，要么是新建一个同内容的 nodeId，下面我会讲怎么处理）
* ADD(书签3) @ t=2
* DELETE(书签4) @ t=2

3点导入合并：按时间重放 → 最终：

* 书签1：**存在**（因为 2 点 add 发生在 1 点 delete 之后）
* 书签2：存在
* 书签3：存在
* 书签4：删除

完全符合你想要的“按时间顺序操作”的直觉。

---

## 关键细节：书签1“加回”到底算不算同一个？

要让“删了又加回”表现得最自然，你有两种策略：

### 策略：同一 nodeId 复活（体验最好）

当用户在浏览器2“新增书签1”时，如果它其实是“把之前删掉的那个再加回来”，你需要能识别它对应的原 nodeId。浏览器原生 API 往往不会给你历史 ID，所以你要自己做映射：

* 给每个书签存一个 `originKey`（比如第一次见到时写入扩展自有字段/存储）
* `originKey` 可以是：`hash(url + title + parentFolderSignature)`
  （或更强：在扩展存储里维护 “内容指纹 → nodeId” 的映射）
* 当检测到用户新增一个书签，若它的指纹命中最近删除的 tombstone，就用同一个 `nodeId` 生成 `ADD(nodeId)`（复活）